逆波兰表达式(Reverse Polish Expression): 逆波兰表达式也叫后缀表达式(Suffix Expression)，这种表达式是为了方便计算机进行处理的表达式。

我们正常所用的表达式是中缀表达式(Infix Expression) 如:(1+2)\*3。

后缀表达式中是没有"()"的!



## 中缀表达式转后缀表达式

**• 人工转化**

假设有一个中缀表达式``a + b * c - (d + e)``

1. 首先将这个中缀表达式的所有运算加括号``((a+(b*c))-(d+e))``
2. 然后将所有运算符放到括号后面，这样就变成了``((a(bc)* )+ (de)+ )-``
3. 把所有括号去掉``abc*+de+-``，最后得出的结果就是后缀表达式。



**• 算法**

规则:
1. 符号栈中，栈顶优先级最高
2. 向符号栈中加入符号时，要对比栈顶符号的优先级是否小于当前符号的优先级，如果小于则直接入栈，如果大于则要将栈内元素弹出，一直弹出至当前的栈顶符号的优先级小于当前符号，然后再将当前符号入栈
3. 如果入栈符号为 ( ，则直接入栈
4. 如果入栈符号为 ) ，则要循环弹栈，一直到栈顶元素为 ( ，为止，最后还要将栈顶元素 ( 弹出

优先级（这个在别人的博客里都没有终点强调过，但是我要重点强调一下）：
+ 优先级小于 \* /，且 + 和 - 的优先级相同， \* 和 / 的优先级相同



&emsp;[(逆波兰表达式（后缀表达式）](https://blog.csdn.net/assiduous_me/article/details/101981332)

## 后缀表达式转中缀表达式(逆波兰表达式求值)



&emsp;借助栈，将数据不断入栈，碰到符号后，取出栈中的2个数字，然后作运算，最后将运算结果再放入栈。最终栈里面只会剩下一个最终结果。

后缀表达式: 1 2 4 + 5 \* + 8 2 / +
1.第一个元素为1，则1入栈，此时栈：1
2.第二个元素为2，则2入栈，此时栈：1 2
3.第三个元素为4，则4入栈，此时栈：1 2 4
4.第四个元素为+，则将栈内元素4和2弹出，并计算2+4=6，将结果6入栈，此时栈：1 6
5.第五个元素为5，则5入栈，此时栈：1 6 5
6.第六个元素为*，则将栈内元素5和6弹出，并计算6\*5=30，将结果30入栈，此时栈：1 30
7.第七个元素为+，则将栈内元素30和1弹出，并计算1+30=31，将结果31入栈，此时栈：31
8.第八个元素为8，则8入栈，此时栈：31 8
9.第九个元素为2，则2入栈，此时栈：31 8 2
10.第十个元素为/，则将栈内元素2和8弹出，并计算8/2=4，将结果4入栈，此时栈：31 4
11.第十一个元素为+，则将栈内元素4和31弹出，并计算31+4=35，将结果35入栈，此时栈：35
12.遍历结束，将栈内结果35返回，所以结果为35

**• 150.逆波兰表达式求值**

```cpp
class Solution {
public:
    unordered_map<string, function<int(int,int)>> opum = {
        {"+", [](int x, int y){ return x + y; }},
        {"-", [](int x, int y){ return x - y; }},
        {"*", [](int x, int y){ return x * y; }},
        {"/", [](int x, int y){ return x / y; }}
    };

    int evalRPN(vector<string>& tokens) 
    {
        int res = 0;
        stack<int> st;
        for(int i = 0; i < tokens.size(); ++i)
        {
            if(opum.find(tokens[i]) == opum.end())
            {
                st.push(stoi(tokens[i]));
            }
            else
            {
                int y = st.top();
                st.pop();
                int x = st.top();
                st.pop();
                int tmp = opum[tokens[i]](x, y);
                st.push(tmp);
            }
        }
        return st.top();
    }
};
```

&emsp;

## 中缀表达式转前缀表达式



<img src="https://pic1.zhimg.com/v2-13317aa43ba516f8a761c70475fb1044_r.jpg" style="zoom:80%;" >

