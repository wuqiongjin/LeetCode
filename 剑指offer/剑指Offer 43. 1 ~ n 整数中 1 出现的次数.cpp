class Solution {
public:
    //思路: (直接暴力统计每个数字出现1的次数是一定不行的, 会超时)
    //我们可以某一个位的值, 让其值为1, 然后计算剩余的位置数字出现的情况. 因为当前位为1, 所以其它位置数字情况出现的总和就是结果中的一部分. 以此类推, 我们从各位开始
    //n = 3 1 0 1 5 9 2
    //举个例子, 我们现固定百位[5]
    //情况1: cur > 1    (cur == 5)
    //[3 1 0 1] [5] [9 2]       //设[5]为cur
    //[0000 ~ 3101] [1] [00 ~ 99]
    //设base = 100; 则 a = n / base / 10; b = n % base;     //a表示cur的前半部分, b表示cur的后半部分
    //"1"在百位出现的次数 res += (a + 1) * base = (3102) * (100)       //注意: 这里用的是base不是b
    //--------------------------------------------------------------------
    //情况2: cur == 1
    //[3 1 0] [1] [5 9 2]
    //①[000 ~ 309] [1] [000 ~ 999]
    //②[310] [1] [000 ~ 592]
    //设base = 1000; 则 a = n / base / 10; b = n % base;
    //"1"在千位出现的次数 res += a * base + 1 * (b + 1);
    //--------------------------------------------------------------------
    //情况3: cur < 1
    //[3 1] [0] [1 5 9 2]
    //[00 ~ 30] [1] [0000 ~ 9999]   //当我们把cur设为1时, 它原本的值是0,这意味着cur的前半部分不能取到最大值
    //"1"在万位出现的次数 res += a * base;
    int countDigitOne(int n) {
        long base = 1;
        int res = 0;
        while(base <= n)
        {
            int a = n / base / 10;
            int cur = (n / base) % 10;  //注意, 取cur的值, 就得这么取, 自己算一算, 先去除cur后面的部分, 然后%10取最后一位, 即是cur的值
            int b = n % base;
            if(cur > 1){
                res += (a + 1) * base;
            }
            else if(cur == 1){
                res += a * base + b + 1;
            }
            else{
                res += a * base;
            }
            base *= 10;
        }
        return res;
    }
};